

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pygmin.landscape.connect_min &mdash; pygmin 0.1 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/scipy.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="top" title="pygmin 0.1 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">pygmin 0.1 documentation</a> &raquo;</li>
          <li><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for pygmin.landscape.connect_min</h1><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="kn">as</span> <span class="nn">nx</span>

<span class="kn">from</span> <span class="nn">pygmin.landscape</span> <span class="kn">import</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">LocalConnect</span>
<span class="kn">from</span> <span class="nn">pygmin.landscape._distance_graph</span> <span class="kn">import</span> <span class="n">_DistanceGraph</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;DoubleEndedConnect&quot;</span><span class="p">]</span>

                     


<div class="viewcode-block" id="DoubleEndedConnect"><a class="viewcode-back" href="../../../generated/pygmin.landscape.DoubleEndedConnect.html#pygmin.landscape.DoubleEndedConnect">[docs]</a><span class="k">class</span> <span class="nc">DoubleEndedConnect</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find a connected network of minima and transition states between min1 and min2</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    min1, min2 : Mimumum() objects</span>
<span class="sd">        the two minima to try to connect</span>
<span class="sd">    pot : potential object</span>
<span class="sd">        the potential</span>
<span class="sd">    mindist : callable</span>
<span class="sd">        the function which returns the optimized minimum distance between</span>
<span class="sd">        two structures</span>
<span class="sd">    database : Database() object</span>
<span class="sd">        the database object, used to save distance calculations so</span>
<span class="sd">        mindist() need only be called once for each minima pair. *Note* the</span>
<span class="sd">        use of this and graph is a bit redundant, this should be cleaned up</span>
<span class="sd">    use_all_min : bool</span>
<span class="sd">        if True, then all known minima and transition states in graph will</span>
<span class="sd">        be used to try to connect min1 and min2.  This requires a mindist()</span>
<span class="sd">        call (or a retrieveal operation from database) for every pair which</span>
<span class="sd">        can take a very long time if many minima are known.</span>
<span class="sd">    niter : int, optional</span>
<span class="sd">        maximum number of iterations</span>
<span class="sd">    verbosity : int</span>
<span class="sd">        this controls how many status messages are printed.  (not really</span>
<span class="sd">        implemented yet)</span>
<span class="sd">    merge_minima : bool</span>
<span class="sd">        if True, minima for which NEB finds no transition state candidates </span>
<span class="sd">        between them will be merged</span>
<span class="sd">    max_dist_merge : float</span>
<span class="sd">        merging minima will be aborted if the distance between them is greater</span>
<span class="sd">        than max_dist_merge</span>
<span class="sd">    local_connect_params : dict</span>
<span class="sd">        parameters passed to the local connect algorithm.  This includes all</span>
<span class="sd">        NEB and all transition state search parameters, along with, e.g. </span>
<span class="sd">        now many times to retry a local connect run.  See documentation for</span>
<span class="sd">        LocalConnect for details.</span>
<span class="sd">    fresh_connect : bool</span>
<span class="sd">        if true, ignore all existing minima and transition states in the</span>
<span class="sd">        database and try to find a new path</span>
<span class="sd">    longest_first : bool</span>
<span class="sd">        if true, always try to connect the longest segment in the path guess</span>
<span class="sd">        first</span>
<span class="sd">    conf_checks : list of callables</span>
<span class="sd">        a list of callable function that determine if a configuration is valid.</span>
<span class="sd">        They must return a bool, and accept the keyword parameters</span>
<span class="sd">        </span>
<span class="sd">            conf_check(energy=energy, coords=coords)</span>
<span class="sd">        </span>
<span class="sd">        If any configuration in a minimum-transition_state-minimum triplet fails</span>
<span class="sd">        a test then the whole triplet is rejected.</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The algorithm is iterative, with each iteration composed of</span>
<span class="sd">    </span>
<span class="sd">    While min1 and min2 are not connected:</span>
<span class="sd">        1) choose a pair of known minima to try to connect</span>
<span class="sd">        </span>
<span class="sd">        2) use NEB to get a guess for the transition states between them</span>
<span class="sd">        </span>
<span class="sd">        3) refine the transition states to desired accuracy</span>
<span class="sd">        </span>
<span class="sd">        4) fall off either side of the transition states to find the two</span>
<span class="sd">        minima associated with that candidate</span>
<span class="sd">        </span>
<span class="sd">        5) add the transition states and associated minima to the known</span>
<span class="sd">        network</span>
<span class="sd">        </span>
<span class="sd">    </span>
<span class="sd">    Of the above, steps 1 and 2 and 3 are the most involved.  2, 3, 4 are </span>
<span class="sd">    wrapped into a separate class called LocalConnect.  See this class and</span>
<span class="sd">    the NEB and FindTransitionState classes for detailed descriptions of </span>
<span class="sd">    these procedures.</span>
<span class="sd">    </span>
<span class="sd">    An important note is that the NEB is used only to get a *guess* for the</span>
<span class="sd">    transition state.  Thus we only want to put enough time and energy into</span>
<span class="sd">    the NEB routine to get the guess close enough that FindTransitionState</span>
<span class="sd">    can refine it to the correct transition state.  FindTransitionState is</span>
<span class="sd">    very fast if the initial guess is good, but can be very slow otherwise.</span>
<span class="sd">    </span>
<span class="sd">    Choose a pair:</span>

<span class="sd">    Here I will describe step 1), the algorithm to find a pair of known</span>
<span class="sd">    minima to try to connect.  This choice will keep in mind that the</span>
<span class="sd">    ultimate goal is to connect min1 and min2.</span>
<span class="sd">    </span>
<span class="sd">    In addition to the input parameter &quot;graph&quot;, we keep a second graph</span>
<span class="sd">    &quot;Gdist&quot; (now wrapped in a separate class _DistanceGraph) which also has </span>
<span class="sd">    minima as the vertices. Gdist has an edge between every pair of nodes. </span>
<span class="sd">    The edge weight between vertices u and v</span>
<span class="sd">    is</span>
<span class="sd">    </span>
<span class="sd">        if u and v are connected by transition states:</span>
<span class="sd">            weight(u, v) = 0. </span>
<span class="sd">        elif we have already tried local_connect on (u,v):</span>
<span class="sd">            weight(u, v) = Infinity</span>
<span class="sd">        else:</span>
<span class="sd">            weight(u, v) = dist(u, v)**2</span>
<span class="sd">    </span>
<span class="sd">    This edge weight is set to Infinity to ensure we don&#39;t repeat </span>
<span class="sd">    LocalConnect runs over and over</span>
<span class="sd">    again.  The minimum weight path between min1 and min2 in Gdist gives a</span>
<span class="sd">    good guess for the best way to try connect min1 and min2.  So the</span>
<span class="sd">    algorithm to find a pair of know minima (trial1, trial2) to try to</span>
<span class="sd">    connect is </span>
<span class="sd">    </span>
<span class="sd">    path = Gdist.minimum_weight_path(min1, min2)</span>
<span class="sd">    trial1, trial2 = minima pair in path with lowest nonzero edge weight. (note:</span>
<span class="sd">    if parameter longest_first is True) then the edgepair with the largest</span>
<span class="sd">    edge weight will be selected) </span>

<span class="sd">    </span>

<span class="sd">    todo:</span>
<span class="sd">        allow user to pass graph</span>
<span class="sd">    </span>
<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    DoubleEndedConnectPar : parallel version of this class</span>
<span class="sd">    LocalConnect : the core algorithm of this routine</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min1</span><span class="p">,</span> <span class="n">min2</span><span class="p">,</span> <span class="n">pot</span><span class="p">,</span> <span class="n">mindist</span><span class="p">,</span> <span class="n">database</span><span class="p">,</span> 
                 <span class="n">use_all_min</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">verbosity</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">merge_minima</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> 
                 <span class="n">max_dist_merge</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">local_connect_params</span><span class="o">=</span><span class="nb">dict</span><span class="p">(),</span>
                 <span class="n">fresh_connect</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">longest_first</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">niter</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">conf_checks</span><span class="o">=</span><span class="bp">None</span>
                 <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minstart</span> <span class="o">=</span> <span class="n">min1</span>
        <span class="k">assert</span> <span class="n">min1</span><span class="o">.</span><span class="n">_id</span> <span class="o">==</span> <span class="n">min1</span><span class="p">,</span> <span class="s">&quot;minima must compare equal with their id </span><span class="si">%d</span><span class="s"> </span><span class="si">%s</span><span class="s"> </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">min1</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">min1</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">min1</span><span class="o">.</span><span class="n">__hash__</span><span class="p">()))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minend</span> <span class="o">=</span> <span class="n">min2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pot</span> <span class="o">=</span> <span class="n">pot</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mindist</span> <span class="o">=</span> <span class="n">mindist</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pairsNEB</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">longest_first</span> <span class="o">=</span> <span class="n">longest_first</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">niter</span> <span class="o">=</span> <span class="n">niter</span>
        <span class="k">if</span> <span class="n">conf_checks</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">conf_checks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">conf_checks</span> <span class="o">=</span> <span class="n">conf_checks</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">verbosity</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">verbosity</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">local_connect_params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="s">&quot;verbosity&quot;</span><span class="p">,</span><span class="n">verbosity</span><span class="p">)]</span> <span class="o">+</span> <span class="n">local_connect_params</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">database</span> <span class="o">=</span> <span class="n">database</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fresh_connect</span> <span class="o">=</span> <span class="n">fresh_connect</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fresh_connect</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">,</span> <span class="n">minima</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minstart</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">minend</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">merge_minima</span> <span class="o">=</span> <span class="n">merge_minima</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_dist_merge</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">max_dist_merge</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dist_graph</span> <span class="o">=</span> <span class="n">_DistanceGraph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mindist</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbosity</span><span class="p">)</span>

        <span class="c">#check if a connection exists before initializing distance Graph</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">areConnected</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minstart</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">minend</span><span class="p">):</span>
            <span class="k">print</span> <span class="s">&quot;minima are already connected.  not initializing distance graph&quot;</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dist_graph</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minstart</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">minend</span><span class="p">,</span> <span class="n">use_all_min</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;************************************************************&quot;</span>
            <span class="k">print</span> <span class="s">&quot;starting a double ended connect run between&quot;</span>
            <span class="k">print</span> <span class="s">&quot;        minimum 1: id </span><span class="si">%d</span><span class="s"> energy </span><span class="si">%f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minstart</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">minstart</span><span class="o">.</span><span class="n">energy</span><span class="p">)</span>
            <span class="k">print</span> <span class="s">&quot;        minimum 2: id </span><span class="si">%d</span><span class="s"> energy </span><span class="si">%f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minend</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">minend</span><span class="o">.</span><span class="n">energy</span><span class="p">)</span>
            <span class="k">print</span> <span class="s">&quot;        dist </span><span class="si">%f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minstart</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">minend</span><span class="p">)</span>
            <span class="k">print</span> <span class="s">&quot;************************************************************&quot;</span>
        
    

    
<div class="viewcode-block" id="DoubleEndedConnect.mergeMinima"><a class="viewcode-back" href="../../../generated/pygmin.landscape.DoubleEndedConnect.mergeMinima.html#pygmin.landscape.DoubleEndedConnect.mergeMinima">[docs]</a>    <span class="k">def</span> <span class="nf">mergeMinima</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min1</span><span class="p">,</span> <span class="n">min2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;merge two minimum objects</span>
<span class="sd">        </span>
<span class="sd">        This will delete min2 and make everything that</span>
<span class="sd">        pointed to min2 point to min1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#prefer to delete the minima with the large id.  this potentially will be easier</span>
        <span class="k">if</span> <span class="n">min2</span><span class="o">.</span><span class="n">_id</span> <span class="o">&lt;</span> <span class="n">min1</span><span class="o">.</span><span class="n">_id</span><span class="p">:</span>
            <span class="n">min1</span><span class="p">,</span> <span class="n">min2</span> <span class="o">=</span> <span class="n">min2</span><span class="p">,</span> <span class="n">min1</span>
        
        <span class="n">debug</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDist</span><span class="p">(</span><span class="n">min1</span><span class="p">,</span> <span class="n">min2</span><span class="p">)</span>
        <span class="k">print</span> <span class="s">&quot;merging minima&quot;</span><span class="p">,</span> <span class="n">min1</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">min2</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="s">&quot;E1-E2&quot;</span><span class="p">,</span> <span class="n">min1</span><span class="o">.</span><span class="n">energy</span> <span class="o">-</span> <span class="n">min2</span><span class="o">.</span><span class="n">energy</span>

        <span class="c">#deal with the case where min1 and/or min2 are the same as minstart and/or minend</span>
        <span class="c">#make sure the one that is deleted (min2) is not minstart or minend</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">min1</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minstart</span> <span class="ow">and</span> <span class="n">min2</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minend</span><span class="p">)</span> <span class="ow">or</span> 
            <span class="p">(</span><span class="n">min2</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minstart</span> <span class="ow">and</span> <span class="n">min1</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minend</span><span class="p">)):</span>
            <span class="k">print</span> <span class="s">&quot;ERROR: trying to merge the start and end minima.  aborting&quot;</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">min2</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minstart</span> <span class="ow">or</span> <span class="n">min2</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minend</span><span class="p">:</span>
            <span class="n">min1</span><span class="p">,</span> <span class="n">min2</span> <span class="o">=</span> <span class="n">min2</span><span class="p">,</span> <span class="n">min1</span>
        
        <span class="c">#print &quot;min1 min2&quot;, min1, min2</span>

        <span class="k">if</span> <span class="n">dist</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_dist_merge</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;    minima merge aborted.  distance is too large&quot;</span><span class="p">,</span> <span class="n">dist</span>
            <span class="k">return</span>
        
<span class="c">#        if debug:</span>
<span class="c">#            #testing</span>
<span class="c">#            if min2 in self.database.minima():</span>
<span class="c">#                print &quot;error, min2 is still in database&quot;</span>
<span class="c">#            for ts in self.database.transition_states():</span>
<span class="c">#                if min2 == ts.minimum1 or min2 == ts.minimum2:</span>
<span class="c">#                    print &quot;error, a transition state attached to min2 is still in database&quot;, ts.minimum1._id, ts.minimum2._id</span>
        
        <span class="c">#merge minima in transition state graph</span>
        <span class="c">#note, this will merge minima in the database also</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">mergeMinima</span><span class="p">(</span><span class="n">min1</span><span class="p">,</span> <span class="n">min2</span><span class="p">,</span> <span class="n">update_database</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="c">#testing</span>
            <span class="k">if</span> <span class="n">min2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
                <span class="k">print</span> <span class="s">&quot;error, min2 is still in self.graph.graph&quot;</span>
            <span class="k">print</span> <span class="s">&quot;self.graph.graph. nnodes&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span>

        <span class="c">#merge minima in distance graph        </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_graph</span><span class="o">.</span><span class="n">mergeMinima</span><span class="p">(</span><span class="n">min1</span><span class="p">,</span> <span class="n">min2</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="DoubleEndedConnect.getDist"><a class="viewcode-back" href="../../../generated/pygmin.landscape.DoubleEndedConnect.getDist.html#pygmin.landscape.DoubleEndedConnect.getDist">[docs]</a>    <span class="k">def</span> <span class="nf">getDist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min1</span><span class="p">,</span> <span class="n">min2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        get the distance between min1 and min2.</span>
<span class="sd">        </span>
<span class="sd">        Try first to get distances from the dictionary distmatrix as this is </span>
<span class="sd">        the fastest access method.  Then try to </span>
<span class="sd">        get distances from the database if they exist, else calculate the</span>
<span class="sd">        distance and save it to the database and distmatrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_graph</span><span class="o">.</span><span class="n">getDist</span><span class="p">(</span><span class="n">min1</span><span class="p">,</span> <span class="n">min2</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_addTransitionState</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">min_ret1</span><span class="p">,</span> <span class="n">min_ret2</span><span class="p">,</span> <span class="n">eigenvec</span><span class="p">,</span> <span class="n">eigenval</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        add a transition state to the database, the transition state graph and</span>
<span class="sd">        the distance graph</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#sanity check for the energies</span>
        <span class="n">me1</span><span class="p">,</span> <span class="n">me2</span> <span class="o">=</span> <span class="n">min_ret1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">min_ret2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">E</span> <span class="o">&lt;</span> <span class="n">me1</span> <span class="ow">or</span> <span class="n">E</span> <span class="o">&lt;</span> <span class="n">me2</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;warning: trying to add a transition state that has energy lower than it&#39;s minima.&quot;</span>
            <span class="k">print</span> <span class="s">&quot;    TS energy&quot;</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="s">&quot;minima energy&quot;</span><span class="p">,</span> <span class="n">me1</span><span class="p">,</span> <span class="n">me2</span>
            <span class="k">print</span> <span class="s">&quot;    aborting&quot;</span>
            <span class="k">return</span> <span class="bp">False</span>
        
        <span class="c">#check the minima and transition states are valid configurations.</span>
        <span class="c">#if any fail, then don&#39;t add anything.  </span>
        <span class="n">configs_ok</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">xtrial</span><span class="p">,</span> <span class="n">etrial</span> <span class="ow">in</span> <span class="p">[</span> <span class="n">min_ret1</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="n">min_ret2</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span> <span class="p">]:</span>
            <span class="k">for</span> <span class="n">check</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">conf_checks</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">check</span><span class="p">(</span><span class="n">energy</span><span class="o">=</span><span class="n">etrial</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">xtrial</span><span class="p">):</span>
                    <span class="n">configs_ok</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">configs_ok</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">configs_ok</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
                
        
        <span class="c">#add the minima to the transition state graph.  </span>
        <span class="c">#This step is important to do first because it returns a Database Minimum object.</span>
        <span class="n">min1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">addMinimum</span><span class="p">(</span><span class="n">min_ret1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">min_ret1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">min2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">addMinimum</span><span class="p">(</span><span class="n">min_ret2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">min_ret2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">min1</span> <span class="o">==</span> <span class="n">min2</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;warning: stepping off the transition state resulted in twice the same minima&quot;</span><span class="p">,</span> <span class="n">min1</span><span class="o">.</span><span class="n">_id</span>
            <span class="k">return</span> <span class="bp">False</span>
        
        

        <span class="k">print</span> <span class="s">&quot;adding transition state&quot;</span><span class="p">,</span> <span class="n">min1</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">min2</span><span class="o">.</span><span class="n">_id</span>
        <span class="c">#update the transition state graph</span>
        <span class="c">#this also updates the database and returns a TransitionState object</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">addTransitionState</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">min1</span><span class="p">,</span> <span class="n">min2</span><span class="p">,</span> <span class="n">eigenvec</span><span class="o">=</span><span class="n">eigenvec</span><span class="p">,</span> <span class="n">eigenval</span><span class="o">=</span><span class="n">eigenval</span><span class="p">)</span>
<span class="c">#        self.graph.refresh()</span>

        <span class="c">#update the distance graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_graph</span><span class="o">.</span><span class="n">addMinimum</span><span class="p">(</span><span class="n">min1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_graph</span><span class="o">.</span><span class="n">addMinimum</span><span class="p">(</span><span class="n">min2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_graph</span><span class="o">.</span><span class="n">setTransitionStateConnection</span><span class="p">(</span><span class="n">min1</span><span class="p">,</span> <span class="n">min2</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">True</span><span class="p">:</span>
            <span class="c">#print some information</span>
            <span class="n">dse</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minend</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">minstart</span><span class="p">)</span>
            <span class="n">msid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minstart</span><span class="o">.</span><span class="n">_id</span>
            <span class="n">meid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minend</span><span class="o">.</span><span class="n">_id</span>
            <span class="n">m1id</span> <span class="o">=</span> <span class="n">min1</span><span class="o">.</span><span class="n">_id</span>
            <span class="n">m2id</span> <span class="o">=</span> <span class="n">min2</span><span class="o">.</span><span class="n">_id</span>
            <span class="k">if</span> <span class="n">min1</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minstart</span> <span class="ow">and</span> <span class="n">min1</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minend</span><span class="p">:</span>
                <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDist</span><span class="p">(</span><span class="n">min1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">minstart</span><span class="p">)</span>
                <span class="n">de</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDist</span><span class="p">(</span><span class="n">min1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">minend</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ds</span> <span class="o">&lt;</span> <span class="n">dse</span> <span class="o">&gt;</span> <span class="n">de</span><span class="p">:</span>
                    <span class="n">triangle</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
                <span class="k">else</span><span class="p">:</span> 
                    <span class="n">triangle</span> <span class="o">=</span> <span class="s">&quot;: new minima not in between start and end&quot;</span>
                <span class="k">print</span> <span class="s">&quot;    distances: </span><span class="si">%4d</span><span class="s"> -&gt; </span><span class="si">%4d</span><span class="s"> = </span><span class="si">%f</span><span class="s">    </span><span class="si">%4d</span><span class="s"> -&gt; </span><span class="si">%4d</span><span class="s"> = </span><span class="si">%f</span><span class="s">    </span><span class="si">%4d</span><span class="s"> -&gt; </span><span class="si">%4d</span><span class="s"> = </span><span class="si">%f</span><span class="s">  </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">msid</span><span class="p">,</span> <span class="n">m1id</span><span class="p">,</span> <span class="n">ds</span><span class="p">,</span> <span class="n">m1id</span><span class="p">,</span> <span class="n">meid</span><span class="p">,</span> <span class="n">de</span><span class="p">,</span> <span class="n">m1id</span><span class="p">,</span> <span class="n">m2id</span><span class="p">,</span> <span class="n">dse</span><span class="p">,</span> <span class="n">triangle</span><span class="p">)</span>
                <span class="c">#print &quot;    dist new min 1 to minstart, minend &quot;, ds, de, dse</span>
            <span class="k">if</span> <span class="n">min2</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minstart</span> <span class="ow">and</span> <span class="n">min2</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minend</span><span class="p">:</span>
                <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDist</span><span class="p">(</span><span class="n">min2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">minstart</span><span class="p">)</span>
                <span class="n">de</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDist</span><span class="p">(</span><span class="n">min2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">minend</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ds</span> <span class="o">&lt;</span> <span class="n">dse</span> <span class="o">&gt;</span> <span class="n">de</span><span class="p">:</span>
                    <span class="n">triangle</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
                <span class="k">else</span><span class="p">:</span> 
                    <span class="n">triangle</span> <span class="o">=</span> <span class="s">&quot;: new minima not in between start and end&quot;</span>
                <span class="k">print</span> <span class="s">&quot;    distances: </span><span class="si">%4d</span><span class="s"> -&gt; </span><span class="si">%4d</span><span class="s"> = </span><span class="si">%f</span><span class="s">    </span><span class="si">%4d</span><span class="s"> -&gt; </span><span class="si">%4d</span><span class="s"> = </span><span class="si">%f</span><span class="s">    </span><span class="si">%4d</span><span class="s"> -&gt; </span><span class="si">%4d</span><span class="s"> = </span><span class="si">%f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">msid</span><span class="p">,</span> <span class="n">m2id</span><span class="p">,</span> <span class="n">ds</span><span class="p">,</span> <span class="n">m2id</span><span class="p">,</span> <span class="n">meid</span><span class="p">,</span> <span class="n">de</span><span class="p">,</span> <span class="n">m2id</span><span class="p">,</span> <span class="n">m2id</span><span class="p">,</span> <span class="n">dse</span><span class="p">)</span>

        
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">_getLocalConnectObject</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">LocalConnect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pot</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mindist</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">local_connect_params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_localConnect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min1</span><span class="p">,</span> <span class="n">min2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        1) NEB to find transition state candidates.  </span>
<span class="sd">        </span>
<span class="sd">        for each transition state candidate:</span>
<span class="sd">        </span>
<span class="sd">            2) refine the transition state candidates</span>
<span class="sd">        </span>
<span class="sd">            3) if successful, fall off either side of the transition state</span>
<span class="sd">            to find the minima the transition state connects. Add the new </span>
<span class="sd">            transition state and minima to the graph </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#Make sure we haven&#39;t already tried this pair and</span>
        <span class="c">#record some data so we don&#39;t try it again in the future</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pairsNEB</span><span class="o">.</span><span class="n">has_key</span><span class="p">((</span><span class="n">min1</span><span class="p">,</span> <span class="n">min2</span><span class="p">)):</span>
            <span class="k">print</span> <span class="s">&quot;WARNING: redoing NEB for minima&quot;</span><span class="p">,</span> <span class="n">min1</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">min2</span><span class="o">.</span><span class="n">_id</span>
            <span class="k">print</span> <span class="s">&quot;         aborting NEB&quot;</span>
            <span class="c">#self._remove_edgeGdist(min1, min2)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dist_graph</span><span class="o">.</span><span class="n">removeEdge</span><span class="p">(</span><span class="n">min1</span><span class="p">,</span> <span class="n">min2</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pairsNEB</span><span class="p">[(</span><span class="n">min1</span><span class="p">,</span> <span class="n">min2</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pairsNEB</span><span class="p">[(</span><span class="n">min2</span><span class="p">,</span> <span class="n">min1</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">True</span>
        
        <span class="c">#Make sure they&#39;re not already connected.  sanity test</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">areConnected</span><span class="p">(</span><span class="n">min1</span><span class="p">,</span> <span class="n">min2</span><span class="p">):</span>
            <span class="k">print</span> <span class="s">&quot;in _local_connect, but minima are already connected. aborting&quot;</span><span class="p">,</span> <span class="n">min1</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">min2</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDist</span><span class="p">(</span><span class="n">min1</span><span class="p">,</span> <span class="n">min2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dist_graph</span><span class="o">.</span><span class="n">setTransitionStateConnection</span><span class="p">(</span><span class="n">min1</span><span class="p">,</span> <span class="n">min2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dist_graph</span><span class="o">.</span><span class="n">checkGraph</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">True</span>
        
        <span class="c">#do local connect run</span>
        <span class="n">local_connect</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getLocalConnectObject</span><span class="p">()</span>        
        <span class="n">res</span> <span class="o">=</span> <span class="n">local_connect</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">min1</span><span class="p">,</span> <span class="n">min2</span><span class="p">)</span>

        <span class="c">#now add each new transition state to the graph and database.</span>
        <span class="n">nsuccess</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">tsret</span><span class="p">,</span> <span class="n">m1ret</span><span class="p">,</span> <span class="n">m2ret</span> <span class="ow">in</span> <span class="n">res</span><span class="o">.</span><span class="n">new_transition_states</span><span class="p">:</span>
            <span class="n">goodts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_addTransitionState</span><span class="p">(</span><span class="n">tsret</span><span class="o">.</span><span class="n">energy</span><span class="p">,</span> <span class="n">tsret</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="n">m1ret</span><span class="p">,</span> <span class="n">m2ret</span><span class="p">,</span> <span class="n">tsret</span><span class="o">.</span><span class="n">eigenvec</span><span class="p">,</span> <span class="n">tsret</span><span class="o">.</span><span class="n">eigenval</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">goodts</span><span class="p">:</span>
                <span class="n">nsuccess</span> <span class="o">+=</span> <span class="mi">1</span>
 
        <span class="c">#check results</span>
        <span class="c">#nclimbing = len(climbing_images)</span>
        <span class="c">#print &quot;from NEB search found&quot;, nclimbing, &quot;transition state candidates&quot;</span>
        <span class="k">if</span> <span class="n">nsuccess</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDist</span><span class="p">(</span><span class="n">min1</span><span class="p">,</span> <span class="n">min2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_dist_merge</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;WARNING: local connect failed and the minima are close. Are the minima really the same?&quot;</span>
                <span class="k">print</span> <span class="s">&quot;         energies:&quot;</span><span class="p">,</span> <span class="n">min1</span><span class="o">.</span><span class="n">energy</span><span class="p">,</span> <span class="n">min2</span><span class="o">.</span><span class="n">energy</span><span class="p">,</span> <span class="s">&quot;distance&quot;</span><span class="p">,</span> <span class="n">dist</span> 
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge_minima</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mergeMinima</span><span class="p">(</span><span class="n">min1</span><span class="p">,</span> <span class="n">min2</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">print</span> <span class="s">&quot;         set merge_minima=True to merge the minima&quot;</span> 
                <span class="k">return</span> <span class="bp">False</span>   


        <span class="c">#remove this edge from Gdist so we don&#39;t try this pair again again</span>
        <span class="c">#self._remove_edgeGdist(min1, min2)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_graph</span><span class="o">.</span><span class="n">removeEdge</span><span class="p">(</span><span class="n">min1</span><span class="p">,</span> <span class="n">min2</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">nsuccess</span> <span class="o">&gt;</span> <span class="mi">0</span>            
    
                
    <span class="k">def</span> <span class="nf">_getNextPair</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        this is the function which attempts to find a clever pair of minima to try to </span>
<span class="sd">        connect with the ultimate goal of connecting minstart and minend</span>
<span class="sd">        </span>
<span class="sd">        this method can be described as follows:</span>
<span class="sd">        </span>
<span class="sd">        make a new graph Gnew which is complete (all vetices connected).  The edges</span>
<span class="sd">        have a weight given by</span>
<span class="sd">        </span>
<span class="sd">        if self.graph.areConnected(u,v):</span>
<span class="sd">            weight(u,v) = 0.</span>
<span class="sd">        else:</span>
<span class="sd">            weight(u,v) = mindist(u,v)</span>
<span class="sd">        </span>
<span class="sd">        if an NEB has been attempted between u and v then the edge is removed.</span>
<span class="sd">        </span>
<span class="sd">        we then find the shortest path between minstart and minend.  We return</span>
<span class="sd">        the pair in this path which has edge weight with the smallest non zero value </span>
<span class="sd">        </span>
<span class="sd">        update: find the shortest path weighted by distance squared.  This penalizes finding</span>
<span class="sd">        the NEB between minima that are very far away.  (Does this too much favor long paths?)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">print</span> <span class="s">&quot;finding a good pair to try to connect&quot;</span>
        <span class="c">#get the shortest path on dist_graph between minstart and minend</span>
        <span class="k">if</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Gdist has&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_graph</span><span class="o">.</span><span class="n">Gdist</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">(),</span> <span class="s">&quot;nodes and&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_graph</span><span class="o">.</span><span class="n">Gdist</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">(),</span> <span class="s">&quot;edges&quot;</span>
        <span class="n">path</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_graph</span><span class="o">.</span><span class="n">shortestPath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minstart</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">minend</span><span class="p">)</span>
        <span class="n">weightsum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">weightsum</span> <span class="o">&gt;=</span> <span class="mf">10e9</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Can&#39;t find any way to try to connect the minima&quot;</span>
            <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>
        
        <span class="c">#get the weights of the path segements</span>
        <span class="n">weightlist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)):</span>
            <span class="n">min1</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">min2</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="c">#            w = weights.get((min1,min2))</span>
<span class="c">#            if w is None:</span>
<span class="c">#                w = weights.get((min2,min1))</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">weightlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">min1</span><span class="p">,</span> <span class="n">min2</span><span class="p">)</span> <span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">True</span><span class="p">:</span>
            <span class="c">#print the path</span>
            <span class="k">print</span> <span class="s">&quot;best guess for path.  (dist=0.0 means the path is known)&quot;</span>
            <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">min1</span><span class="p">,</span> <span class="n">min2</span> <span class="ow">in</span> <span class="n">weightlist</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="mf">1e-6</span><span class="p">:</span>
                    <span class="n">dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDist</span><span class="p">(</span><span class="n">min1</span><span class="p">,</span> <span class="n">min2</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dist</span> <span class="o">=</span> <span class="n">w</span>
                <span class="k">print</span> <span class="s">&quot;    path guess&quot;</span><span class="p">,</span> <span class="n">min1</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">min2</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">dist</span>

        <span class="c">#select which minima pair to return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">longest_first</span><span class="p">:</span>
            <span class="n">weightlist</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="n">w</span><span class="p">,</span> <span class="n">min1</span><span class="p">,</span> <span class="n">min2</span> <span class="o">=</span> <span class="n">weightlist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">weightlist</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">min1</span><span class="p">,</span> <span class="n">min2</span> <span class="ow">in</span> <span class="n">weightlist</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="mf">1e-6</span><span class="p">:</span>
                    <span class="k">break</span>
        <span class="k">return</span> <span class="n">min1</span><span class="p">,</span> <span class="n">min2</span>
                
    
<div class="viewcode-block" id="DoubleEndedConnect.connect"><a class="viewcode-back" href="../../../generated/pygmin.landscape.DoubleEndedConnect.connect.html#pygmin.landscape.DoubleEndedConnect.connect">[docs]</a>    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        the main loop of the algorithm</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">NEBattempts</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">niter</span><span class="p">):</span>
            <span class="c">#do some book keeping</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dist_graph</span><span class="o">.</span><span class="n">updateDatabase</span><span class="p">()</span>
            
            <span class="c">#stop if we&#39;re done</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">areConnected</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minstart</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">minend</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dist_graph</span><span class="o">.</span><span class="n">updateDatabase</span><span class="p">(</span><span class="n">force</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="k">print</span> <span class="s">&quot;found connection!&quot;</span>
                <span class="k">return</span>
            
            <span class="k">print</span> <span class="s">&quot;&quot;</span>
            <span class="k">print</span> <span class="s">&quot;======== starting connect cycle&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="s">&quot;========&quot;</span>
            <span class="c">#get pair of minima to try to connect</span>
            <span class="n">min1</span><span class="p">,</span> <span class="n">min2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getNextPair</span><span class="p">()</span>
            
            <span class="c">#fail if we can&#39;t find a good pair to try</span>
            <span class="k">if</span> <span class="n">min1</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">min2</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">break</span>
            
            <span class="c">#try to connect those minima            </span>
            <span class="n">local_success</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_localConnect</span><span class="p">(</span><span class="n">min1</span><span class="p">,</span> <span class="n">min2</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="bp">True</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c">#do some sanity checks</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dist_graph</span><span class="o">.</span><span class="n">checkGraph</span><span class="p">()</span>



            
        <span class="k">print</span> <span class="s">&quot;failed to find connection between&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">minstart</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">minend</span><span class="o">.</span><span class="n">_id</span>
</div>
<div class="viewcode-block" id="DoubleEndedConnect.returnPath"><a class="viewcode-back" href="../../../generated/pygmin.landscape.DoubleEndedConnect.returnPath.html#pygmin.landscape.DoubleEndedConnect.returnPath">[docs]</a>    <span class="k">def</span> <span class="nf">returnPath</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return information about the path&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">areConnected</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minstart</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">minend</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="n">minima</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">minstart</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">minend</span><span class="p">)</span>
        <span class="n">transition_states</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mints</span> <span class="o">=</span> <span class="p">[</span><span class="n">minima</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">minima</span><span class="p">)):</span>
            <span class="n">m1</span> <span class="o">=</span> <span class="n">minima</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">m2</span> <span class="o">=</span> <span class="n">minima</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="o">.</span><span class="n">getTransitionState</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">)</span>
            <span class="n">transition_states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
            <span class="n">mints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
            <span class="n">mints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m2</span><span class="p">)</span>
        
        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mints</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">mints</span><span class="p">)):</span>
            <span class="n">coords1</span> <span class="o">=</span> <span class="n">mints</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">coords</span>
            <span class="n">coords2</span> <span class="o">=</span> <span class="n">mints</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">coords</span>
            <span class="n">dist</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mindist</span><span class="p">(</span><span class="n">coords1</span><span class="p">,</span> <span class="n">coords2</span><span class="p">)</span>
            <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dist</span>
        <span class="n">energies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">m</span><span class="o">.</span><span class="n">energy</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mints</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">mints</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">energies</span>
        


<span class="c">###########################################################</span>
<span class="c">#only testing stuff below here</span>
<span class="c">###########################################################</span>
</div></div>
<span class="k">def</span> <span class="nf">getSetOfMinLJ</span><span class="p">(</span><span class="n">natoms</span> <span class="o">=</span> <span class="mi">32</span><span class="p">):</span> <span class="c">#for testing purposes</span>
    <span class="kn">from</span> <span class="nn">pygmin.potentials.lj</span> <span class="kn">import</span> <span class="n">LJ</span>
    <span class="n">pot</span> <span class="o">=</span> <span class="n">LJ</span><span class="p">()</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">natoms</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">pygmin.basinhopping</span> <span class="kn">import</span> <span class="n">BasinHopping</span>
    <span class="kn">from</span> <span class="nn">pygmin.takestep.displace</span> <span class="kn">import</span> <span class="n">RandomDisplacement</span>
    <span class="kn">from</span> <span class="nn">pygmin.takestep.adaptive</span> <span class="kn">import</span> <span class="n">AdaptiveStepsize</span>
    <span class="kn">from</span> <span class="nn">pygmin.storage.database</span> <span class="kn">import</span> <span class="n">Database</span>
    <span class="kn">import</span> <span class="nn">os</span>
    <span class="c">#dbfile = &quot;test.db&quot;</span>
    <span class="c">#os.remove(dbfile)</span>
    <span class="c">#saveit = Database(db=dbfile)</span>
    <span class="n">saveit</span> <span class="o">=</span> <span class="n">Database</span><span class="p">()</span>
    <span class="n">takestep1</span> <span class="o">=</span> <span class="n">RandomDisplacement</span><span class="p">()</span>
    <span class="n">takestep</span> <span class="o">=</span> <span class="n">AdaptiveStepsize</span><span class="p">(</span><span class="n">takestep1</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
    <span class="n">bh</span> <span class="o">=</span> <span class="n">BasinHopping</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">pot</span><span class="p">,</span> <span class="n">takestep</span><span class="p">,</span> <span class="n">storage</span><span class="o">=</span><span class="n">saveit</span><span class="o">.</span><span class="n">minimum_adder</span><span class="p">(),</span> <span class="n">outstream</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
    <span class="n">bh</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pot</span><span class="p">,</span> <span class="n">saveit</span>


<span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">Connect</span><span class="o">=</span><span class="n">DoubleEndedConnect</span><span class="p">,</span> <span class="n">natoms</span><span class="o">=</span><span class="mi">16</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">pygmin.landscape</span> <span class="kn">import</span> <span class="n">Graph</span>
    <span class="kn">from</span> <span class="nn">pygmin.mindist</span> <span class="kn">import</span> <span class="n">minPermDistStochastic</span><span class="p">,</span> <span class="n">MinDistWrapper</span>
    <span class="kn">from</span> <span class="nn">pygmin.storage.database</span> <span class="kn">import</span> <span class="n">Database</span>
    <span class="kn">import</span> <span class="nn">pygmin.defaults</span> <span class="kn">as</span> <span class="nn">defaults</span>
    <span class="n">defaults</span><span class="o">.</span><span class="n">quenchParams</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;iprint&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
    <span class="c">#get min1</span>
    <span class="n">pot</span><span class="p">,</span> <span class="n">database</span> <span class="o">=</span> <span class="n">getSetOfMinLJ</span><span class="p">(</span><span class="n">natoms</span><span class="p">)</span>
<span class="c">#    from pygmin.potentials.lj import LJ</span>
<span class="c">#    pot = LJ()</span>
<span class="c">#    saveit = Database(db=&quot;test.db&quot;)</span>
    <span class="n">minima</span> <span class="o">=</span> <span class="n">database</span><span class="o">.</span><span class="n">minima</span><span class="p">()</span>
    <span class="n">min1</span> <span class="o">=</span> <span class="n">minima</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">min2</span> <span class="o">=</span> <span class="n">minima</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">print</span> <span class="n">min1</span><span class="o">.</span><span class="n">energy</span><span class="p">,</span> <span class="n">min2</span><span class="o">.</span><span class="n">energy</span>
    
    <span class="n">mindist</span> <span class="o">=</span> <span class="n">MinDistWrapper</span><span class="p">(</span><span class="n">minPermDistStochastic</span><span class="p">,</span> <span class="n">permlist</span><span class="o">=</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="n">natoms</span><span class="p">)],</span> <span class="n">niter</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="bp">False</span><span class="p">:</span>
        <span class="c">#test to see if min1 and min2 are already connected</span>
        <span class="n">connected</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">areConnected</span><span class="p">(</span><span class="n">min1</span><span class="p">,</span> <span class="n">min2</span><span class="p">)</span>
        <span class="k">print</span> <span class="s">&quot;at start are minima connected?&quot;</span><span class="p">,</span> <span class="n">connected</span>
        <span class="k">return</span>
 
    <span class="n">connect</span> <span class="o">=</span> <span class="n">Connect</span><span class="p">(</span><span class="n">min1</span><span class="p">,</span> <span class="n">min2</span><span class="p">,</span> <span class="n">pot</span><span class="p">,</span> <span class="n">mindist</span><span class="p">,</span> <span class="n">database</span><span class="p">)</span>
    <span class="n">connect</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>
    
    <span class="n">graph</span> <span class="o">=</span> <span class="n">connect</span><span class="o">.</span><span class="n">graph</span>
    <span class="k">if</span> <span class="bp">False</span><span class="p">:</span>
        <span class="k">print</span> <span class="n">graph</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
            <span class="k">print</span> <span class="n">node</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">energy</span>
    <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">storage</span><span class="o">.</span><span class="n">transition_states</span><span class="p">():</span>
        <span class="k">print</span> <span class="n">ts</span><span class="o">.</span><span class="n">minimum1</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span><span class="n">ts</span><span class="o">.</span><span class="n">minimum2</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="s">&quot;E&quot;</span><span class="p">,</span> <span class="n">ts</span><span class="o">.</span><span class="n">minimum1</span><span class="o">.</span><span class="n">energy</span><span class="p">,</span> <span class="n">ts</span><span class="o">.</span><span class="n">minimum2</span><span class="o">.</span><span class="n">energy</span><span class="p">,</span> <span class="n">ts</span><span class="o">.</span><span class="n">energy</span>
        
    <span class="n">ret</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">getPath</span><span class="p">(</span><span class="n">min1</span><span class="p">,</span> <span class="n">min2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;no path found&quot;</span>
        <span class="k">return</span>
    <span class="n">distances</span><span class="p">,</span> <span class="n">path</span> <span class="o">=</span> <span class="n">ret</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;path.out&quot;</span><span class="p">,</span> <span class="s">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fout</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">m1</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">m2</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">n1</span> <span class="o">=</span> <span class="n">m1</span><span class="o">.</span><span class="n">_id</span>
            <span class="n">m2</span> <span class="o">=</span> <span class="n">m2</span><span class="o">.</span><span class="n">_id</span>
<span class="c">#            ts = graph._getTS(n1, n2)</span>
<span class="c">#            print &quot;path&quot;, n1, &quot;-&gt;&quot;, n2, m1.E, &quot;/-&gt;&quot;, ts.E, &quot;\-&gt;&quot;, m2.E</span>
            <span class="n">fout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%f</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">m1</span><span class="o">.</span><span class="n">energy</span><span class="p">)</span>
            <span class="n">fout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%f</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">ts</span><span class="o">.</span><span class="n">energy</span><span class="p">)</span>
        <span class="n">m2</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">n2</span> <span class="o">=</span> <span class="n">m2</span><span class="o">.</span><span class="n">_id</span>
        <span class="n">fout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%f</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">m2</span><span class="o">.</span><span class="n">energy</span><span class="p">)</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">test</span><span class="p">(</span><span class="n">natoms</span><span class="o">=</span><span class="mi">38</span><span class="p">)</span>


    
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">pygmin 0.1 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Victor Rühle, Jacob Stevenson.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>