

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pygmin.utils.disconnectivity_graph &mdash; pygmin 0.1 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/scipy.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="top" title="pygmin 0.1 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">pygmin 0.1 documentation</a> &raquo;</li>
          <li><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for pygmin.utils.disconnectivity_graph</h1><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="kn">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="kn">from</span> <span class="nn">pygmin.landscape</span> <span class="kn">import</span> <span class="n">Graph</span>


        
<span class="k">class</span> <span class="nc">Tree</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    a Tree graph</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subtrees</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">=</span><span class="n">parent</span>
    
    <span class="k">def</span> <span class="nf">make_branch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">newtree</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subtrees</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newtree</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">newtree</span>
    
    <span class="k">def</span> <span class="nf">get_subtrees</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subtrees</span>
    
    <span class="k">def</span> <span class="nf">number_of_branches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subtrees</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_branches</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>
    
    <span class="k">def</span> <span class="nf">number_of_leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subtrees</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nleaves</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nleaves</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subtrees</span><span class="p">:</span>
                <span class="n">nleaves</span> <span class="o">+=</span> <span class="n">tree</span><span class="o">.</span><span class="n">number_of_leaves</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">nleaves</span>
    
    <span class="k">def</span> <span class="nf">get_leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subtrees</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">leaves</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">leaves</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subtrees</span><span class="p">:</span>
                <span class="n">leaves</span> <span class="o">+=</span> <span class="n">tree</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">leaves</span>

                

<div class="viewcode-block" id="DisconnectivityGraph"><a class="viewcode-back" href="../../../generated/pygmin.utils.disconnectivity_graph.DisconnectivityGraph.html#pygmin.utils.disconnectivity_graph.DisconnectivityGraph">[docs]</a><span class="k">class</span> <span class="nc">DisconnectivityGraph</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    make a disconnectivity graph</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    graph : a networkx graph</span>
<span class="sd">        a graph with Minimum objects as nodes and transition</span>
<span class="sd">        states defining the edges.  You can use</span>
<span class="sd">        pygmin.landscape.Graph to create this from a database.</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; from pygmin.landscape import Graph</span>
<span class="sd">        &gt;&gt;&gt; graphwrapper = Graph(database)</span>
<span class="sd">        &gt;&gt;&gt; dg = DisconnectivityGraph(graphwrapper.graph)</span>
<span class="sd">         </span>
<span class="sd">    nlevels : int</span>
<span class="sd">        how many levels at which to bin the transition states</span>
<span class="sd">    Emax : float</span>
<span class="sd">        maximum energy for transition state cutoff.  Default</span>
<span class="sd">        is the maximum energy of all transition states.</span>

<span class="sd">    minima : list of Minima</span>
<span class="sd">        a list of minima to ensure are displayed in the graph.</span>
<span class="sd">        e.g. they will be displayed even if they&#39;re in a connected</span>
<span class="sd">        cluster smaller than smaller than subgraph_size</span>
<span class="sd">    subgraph_size : int</span>
<span class="sd">        if subgraph_size is not None then all disconnected graphs</span>
<span class="sd">        of size greater than subraph_size will be included.</span>

<span class="sd">    order_by_energy : bool</span>
<span class="sd">        order the subtrees by placing ones with lower energy closer</span>
<span class="sd">        to the center</span>
<span class="sd">    order_by_basin_size : bool</span>
<span class="sd">        order the subtrees by placing larger basins closer to the center</span>
<span class="sd">    center_gmin : bool</span>
<span class="sd">        when a node splits into its daughter</span>
<span class="sd">        nodes, the one containing the global minimum is always placed centrally</span>
<span class="sd">        (even if other nodes carry more minima). This does not guarantee that</span>
<span class="sd">        the global minimum is central in the overall diagram because other</span>
<span class="sd">        nodes may push the one containing the global minimum over to one side</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">minima</span><span class="o">=</span><span class="p">[],</span> <span class="n">nlevels</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">Emax</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">subgraph_size</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">order_by_energy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">order_by_basin_size</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                 <span class="n">center_gmin</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">include_gmin</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nlevels</span> <span class="o">=</span> <span class="n">nlevels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Emax</span> <span class="o">=</span> <span class="n">Emax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subgraph_size</span> <span class="o">=</span> <span class="n">subgraph_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order_by_basin_size</span> <span class="o">=</span> <span class="n">order_by_basin_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order_by_energy</span> <span class="o">=</span> <span class="n">order_by_energy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">center_gmin</span> <span class="o">=</span> <span class="n">center_gmin</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">gmin0</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">center_gmin</span><span class="p">:</span>
            <span class="n">include_gmin</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">min0list</span> <span class="o">=</span> <span class="n">minima</span>
        <span class="k">if</span> <span class="n">include_gmin</span><span class="p">:</span>
            <span class="c">#find the minimum energy node</span>
            <span class="n">elist</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">energy</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="p">]</span>
            <span class="n">elist</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">elist</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gmin0</span> <span class="o">=</span> <span class="n">elist</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">min0list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gmin0</span><span class="p">)</span>
<span class="c">#            print &quot;min0&quot;, self.min0.energy, self.min0._id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transition_states</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_edge_attributes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="s">&quot;ts&quot;</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">_getTS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min1</span><span class="p">,</span> <span class="n">min2</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transition_states</span><span class="p">[(</span><span class="n">min1</span><span class="p">,</span> <span class="n">min2</span><span class="p">)]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transition_states</span><span class="p">[(</span><span class="n">min2</span><span class="p">,</span> <span class="n">min1</span><span class="p">)]</span>


    <span class="c">#############################################################</span>
    <span class="c">#functions for building the tree by splitting the graph into</span>
    <span class="c">#connected components at each level </span>
    <span class="c">#############################################################</span>


    <span class="k">def</span> <span class="nf">_connected_component_subgraphs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        redefine the networkx version because they use deepcopy</span>
<span class="sd">        on the nodes and edges</span>
<span class="sd">        </span>
<span class="sd">        this was coppied and only slightly modified from the original</span>
<span class="sd">        source</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cc</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="n">graph_list</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cc</span><span class="p">:</span>
            <span class="n">graph_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">graph_list</span>
    
    <span class="k">def</span> <span class="nf">_split_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">ethresh</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        make a new graph from the old one after excluding edges with energy &gt; ethresh</span>
<span class="sd">        </span>
<span class="sd">        return a list of graphs, one for each connected component.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">newgraph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
        <span class="n">newgraph</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getTS</span><span class="p">(</span><span class="o">*</span><span class="n">edge</span><span class="p">)</span><span class="o">.</span><span class="n">energy</span> <span class="o">&lt;</span> <span class="n">ethresh</span><span class="p">:</span>
                <span class="n">newgraph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="o">*</span><span class="n">edge</span><span class="p">)</span>
<span class="c">#        return nx.connected_component_subgraphs(newgraph)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connected_component_subgraphs</span><span class="p">(</span><span class="n">newgraph</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_recursive_new_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent_tree</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">energy_levels</span><span class="p">,</span> <span class="n">ilevel</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ilevel</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span>
        <span class="n">ethresh</span> <span class="o">=</span> <span class="n">energy_levels</span><span class="p">[</span><span class="n">ilevel</span><span class="p">]</span>
<span class="c">#        if graph.number_of_edges() == 0: return</span>
        
<span class="c">#        leaves = {}</span>
        <span class="n">subgraphs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split_graph</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">ethresh</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">subgraphs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nx</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">minimum</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span> <span class="k">break</span>
                <span class="n">newtree</span> <span class="o">=</span> <span class="n">parent_tree</span><span class="o">.</span><span class="n">make_branch</span><span class="p">()</span>
                <span class="n">newtree</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;minimum&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">minimum</span> 
                <span class="n">newtree</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;ilevel&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ilevel</span> 
                <span class="n">newtree</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;ethresh&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ethresh</span> 
<span class="c">#                leaves[minimum] = newtree</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newtree</span> <span class="o">=</span> <span class="n">parent_tree</span><span class="o">.</span><span class="n">make_branch</span><span class="p">()</span>
                <span class="n">newtree</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;ilevel&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ilevel</span> 
                <span class="n">newtree</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;ethresh&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ethresh</span>                 
                <span class="bp">self</span><span class="o">.</span><span class="n">_recursive_new_tree</span><span class="p">(</span><span class="n">newtree</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">energy_levels</span><span class="p">,</span> <span class="n">ilevel</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_make_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">energy_levels</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tree_graph</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">()</span>
<span class="c">#        print tree_graph</span>
        <span class="n">tree_graph</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;ilevel&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">energy_levels</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">de</span> <span class="o">=</span> <span class="n">energy_levels</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">energy_levels</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">tree_graph</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;ethresh&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">energy_levels</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1.</span><span class="o">*</span><span class="n">de</span>
        
    
        <span class="c">#deal with the case that we have multiple disconnected graphs</span>
<span class="c">#        subgraphs = self._connected_component_subgraphs(graph)</span>
        <span class="n">subgraphs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split_graph</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">energy_levels</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subgraphs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c">#if the highest level tree has more than one graph then </span>
            <span class="c">#they are disconnected graphs</span>
            <span class="n">tree_graph</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;children_not_connected&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">subgraphs</span><span class="p">:</span>
            <span class="n">newtree</span> <span class="o">=</span> <span class="n">tree_graph</span><span class="o">.</span><span class="n">make_branch</span><span class="p">()</span>
            <span class="n">newtree</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;ilevel&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">energy_levels</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span>
            <span class="n">newtree</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;ethresh&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">energy_levels</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_recursive_new_tree</span><span class="p">(</span><span class="n">newtree</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">energy_levels</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">energy_levels</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">tree_graph</span>            

    <span class="c">##########################################################</span>
    <span class="c">#functions for determining the x position of the branches</span>
    <span class="c">#and leaves</span>
    <span class="c">##########################################################</span>

    <span class="k">def</span> <span class="nf">_recursive_layout_x_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">dx_per_min</span><span class="p">):</span>
<span class="c">#        nbranches = tree.number_of_branches()</span>
        <span class="n">nminima</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">number_of_leaves</span><span class="p">()</span>
        <span class="n">subtrees</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">get_subtrees</span><span class="p">()</span>
        <span class="n">subtrees</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order_trees</span><span class="p">(</span><span class="n">subtrees</span><span class="p">)</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;x&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xmin</span> <span class="o">+</span> <span class="n">dx_per_min</span> <span class="o">*</span> <span class="n">nminima</span> <span class="o">/</span> <span class="mf">2.</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">xmin</span>
        <span class="k">for</span> <span class="n">subtree</span> <span class="ow">in</span> <span class="n">subtrees</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_recursive_layout_x_axis</span><span class="p">(</span><span class="n">subtree</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">dx_per_min</span><span class="p">)</span>
            <span class="n">nminima_sub</span> <span class="o">=</span> <span class="n">subtree</span><span class="o">.</span><span class="n">number_of_leaves</span><span class="p">()</span>
            <span class="n">x</span> <span class="o">+=</span> <span class="n">dx_per_min</span> <span class="o">*</span> <span class="n">nminima_sub</span>
  
    <span class="k">def</span> <span class="nf">_layout_x_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xmin</span> <span class="o">=</span> <span class="mf">4.0</span>
        <span class="n">dx_per_min</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_recursive_layout_x_axis</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">dx_per_min</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_tree_get_minimum_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">emin</span><span class="o">=</span><span class="mf">1e100</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
            <span class="n">energy</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;minimum&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">energy</span>
            <span class="k">if</span> <span class="n">energy</span> <span class="o">&lt;</span> <span class="n">emin</span><span class="p">:</span>
                <span class="n">emin</span> <span class="o">=</span> <span class="n">energy</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">subtree</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">get_subtrees</span><span class="p">():</span>
                <span class="n">emin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tree_get_minimum_energy</span><span class="p">(</span><span class="n">subtree</span><span class="p">,</span> <span class="n">emin</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">emin</span>

    <span class="k">def</span> <span class="nf">_order_trees</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trees</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        order a list of trees for printing</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">order_by_energy</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order_trees_by_minimum_energy</span><span class="p">(</span><span class="n">trees</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order_trees_by_most_leaves</span><span class="p">(</span><span class="n">trees</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_order_trees_final</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree_value_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tree_value_list :</span>
<span class="sd">            a list of (value, tree) pairs where value is the object</span>
<span class="sd">            by which to sort the trees</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        treelist :</span>
<span class="sd">            a list of trees ordered with the lowest in the center</span>
<span class="sd">            and the others placed successively on the left and right</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mylist</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">tree_value_list</span><span class="p">)</span>
        <span class="n">neworder</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mylist</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">neworder</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mylist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">neworder</span><span class="o">.</span><span class="n">appendleft</span><span class="p">(</span><span class="n">mylist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">neworder</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_ensure_gmin_is_center</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree_value_list</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gmin0</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="k">return</span>
        <span class="n">min0index</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tree_value_list</span><span class="p">)):</span>
            <span class="n">v</span><span class="p">,</span> <span class="n">tree</span> <span class="o">=</span> <span class="n">tree_value_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gmin0</span> <span class="ow">in</span> <span class="p">[</span> <span class="n">leaf</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;minimum&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()]:</span>
                <span class="n">min0index</span> <span class="o">=</span> <span class="n">i</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">min0index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">minvalue</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">tree_value_list</span><span class="p">])</span>
            <span class="c">#replace the value with a lower one</span>
            <span class="c">#for the tree containing min0</span>
            <span class="n">newvalue</span> <span class="o">=</span> <span class="n">minvalue</span> <span class="o">-</span> <span class="mi">1</span> <span class="c">#this won&#39;t word for non number values</span>
            <span class="n">tree_value_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">newvalue</span><span class="p">,</span> <span class="n">tree_value_list</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> 
        <span class="k">return</span> <span class="n">tree_value_list</span> 

            
        

    <span class="k">def</span> <span class="nf">_order_trees_by_most_leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trees</span><span class="p">):</span>
<span class="c">#        if self.center_gmin:</span>
<span class="c">#            return self._order_trees_by_most_leaves_and_global_min(trees)</span>
        <span class="n">mylist</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">number_of_leaves</span><span class="p">(),</span> <span class="n">tree</span><span class="p">)</span> <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">trees</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">center_gmin</span><span class="p">:</span>
            <span class="n">mylist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_gmin_is_center</span><span class="p">(</span><span class="n">mylist</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order_trees_final</span><span class="p">(</span><span class="n">mylist</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_order_trees_by_minimum_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trees</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        order trees with by the lowest energy minimum.  the global minimum</span>
<span class="sd">        goes in the center, with the remaining being placed alternating on the</span>
<span class="sd">        left and on the right.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mylist</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tree_get_minimum_energy</span><span class="p">(</span><span class="n">tree</span><span class="p">),</span> <span class="n">tree</span><span class="p">)</span> <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">trees</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order_trees_final</span><span class="p">(</span><span class="n">mylist</span><span class="p">)</span>
                        

    <span class="k">def</span> <span class="nf">_get_energy_levels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        combine input and the graph data to determine what the </span>
<span class="sd">        energy levels will be.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#define the energy levels</span>
        <span class="n">elist</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_getTS</span><span class="p">(</span><span class="o">*</span><span class="n">edge</span><span class="p">)</span><span class="o">.</span><span class="n">energy</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">()]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">elist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;there are no edges in the graph.  Is the global minimum connected?&quot;</span><span class="p">)</span>
        <span class="n">emin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">elist</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Emax</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">emax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">elist</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">emax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Emax</span>
        <span class="n">de</span> <span class="o">=</span> <span class="p">(</span><span class="n">emax</span> <span class="o">-</span> <span class="n">emin</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nlevels</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c">#the upper edge of the bins</span>
        <span class="n">elower</span> <span class="o">=</span> <span class="p">[</span><span class="n">emin</span> <span class="o">+</span> <span class="n">de</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nlevels</span><span class="p">)]</span>
        <span class="n">elevels</span> <span class="o">=</span> <span class="n">elower</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">emin</span> <span class="o">+</span> <span class="n">de</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nlevels</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">elower</span>

    <span class="c">#######################################################################</span>
    <span class="c">#functions which return the line segments that make up the visual graph</span>
    <span class="c">#######################################################################</span>

    <span class="k">def</span> <span class="nf">_get_line_segment_recursive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line_segments</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">eoffset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        add the line segment connecting this tree to it&#39;s parent</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">is_leaf</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">xparent</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">]</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">]</span>
            <span class="n">yparent</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;ethresh&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">is_leaf</span><span class="p">:</span>
                <span class="n">ylow</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;minimum&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">energy</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ylow</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;ethresh&quot;</span><span class="p">]</span>
            <span class="n">yhigh</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">yparent</span> <span class="o">-</span> <span class="n">eoffset</span><span class="p">,</span> <span class="n">ylow</span><span class="p">)</span>
            <span class="c">#add vertical line segment</span>
            <span class="n">line_segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">],</span> <span class="p">[</span><span class="n">ylow</span><span class="p">,</span> <span class="n">yhigh</span><span class="p">])</span> <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">tree</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s">&quot;children_not_connected&quot;</span><span class="p">):</span>
                <span class="c">#add angled line segment</span>
                <span class="n">line_segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">([</span><span class="n">xparent</span><span class="p">,</span> <span class="n">x</span><span class="p">],</span> <span class="p">[</span><span class="n">yparent</span><span class="p">,</span><span class="n">yhigh</span><span class="p">])</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">subtree</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">get_subtrees</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_line_segment_recursive</span><span class="p">(</span><span class="n">line_segments</span><span class="p">,</span> <span class="n">subtree</span><span class="p">,</span> <span class="n">eoffset</span><span class="p">)</span>

        
    <span class="k">def</span> <span class="nf">_get_line_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">eoffset</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        get all the line segments for drawing the connection between </span>
<span class="sd">        each minimum to it&#39;s parent node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">line_segments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_get_line_segment_recursive</span><span class="p">(</span><span class="n">line_segments</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">eoffset</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">line_segments</span>
    
    
    
<div class="viewcode-block" id="DisconnectivityGraph.get_minima_layout"><a class="viewcode-back" href="../../../generated/pygmin.utils.disconnectivity_graph.DisconnectivityGraph.get_minima_layout.html#pygmin.utils.disconnectivity_graph.DisconnectivityGraph.get_minima_layout">[docs]</a>    <span class="k">def</span> <span class="nf">get_minima_layout</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        return the x position of the minima        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">leaves</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_graph</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()</span>
        <span class="n">minima</span> <span class="o">=</span> <span class="p">[</span><span class="n">leaf</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;minimum&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">leaves</span><span class="p">]</span>
        <span class="n">xpos</span> <span class="o">=</span> <span class="p">[</span><span class="n">leaf</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;x&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">leaves</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">xpos</span><span class="p">,</span> <span class="n">minima</span>
    </div>
    <span class="k">def</span> <span class="nf">_remove_nodes_with_few_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">nmin</span><span class="p">):</span>
        <span class="n">rmlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">nmin</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rmlist</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gmin0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gmin0</span> <span class="ow">in</span> <span class="n">rmlist</span><span class="p">:</span>
                    <span class="k">print</span> <span class="s">&quot;global minimum has&quot;</span><span class="p">,</span> <span class="n">graph</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gmin0</span><span class="p">),</span> <span class="s">&quot;edges, not showing in graph&quot;</span>
            <span class="k">print</span> <span class="s">&quot;removing&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">rmlist</span><span class="p">),</span> <span class="s">&quot;minima from graph with fewer than&quot;</span><span class="p">,</span> <span class="n">nmin</span><span class="p">,</span> <span class="s">&quot;edges&quot;</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">rmlist</span><span class="p">:</span>
                <span class="n">graph</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">graph</span>

    
    <span class="k">def</span> <span class="nf">_remove_high_energy_minima</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">emax</span><span class="p">):</span>
        <span class="n">rmlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">energy</span> <span class="o">&gt;</span> <span class="n">emax</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rmlist</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;removing nodes with energy higher than&quot;</span><span class="p">,</span> <span class="n">emax</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">rmlist</span><span class="p">:</span>
            <span class="n">graph</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">graph</span>

    <span class="k">def</span> <span class="nf">_reduce_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">min0list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;determine how much of the graph</span>
<span class="sd">        to include in the disconnectivity graph</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">used_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c">#make sure we include the subgraph containing min0</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">min0list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c">#use the biggest connected cluster</span>
            <span class="n">cc</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
            <span class="n">used_nodes</span> <span class="o">+=</span> <span class="n">cc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c">#list is ordered by size of cluster</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">min0</span> <span class="ow">in</span> <span class="n">min0list</span><span class="p">:</span>
                <span class="n">used_nodes</span> <span class="o">+=</span> <span class="n">nx</span><span class="o">.</span><span class="n">node_connected_component</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">min0</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">subgraph_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">node_lists</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">nodes</span> <span class="ow">in</span> <span class="n">node_lists</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subgraph_size</span><span class="p">:</span>
                    <span class="n">used_nodes</span> <span class="o">+=</span> <span class="n">nodes</span>

        <span class="n">newgraph</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">used_nodes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">newgraph</span>

        
    
<div class="viewcode-block" id="DisconnectivityGraph.calculate"><a class="viewcode-back" href="../../../generated/pygmin.utils.disconnectivity_graph.DisconnectivityGraph.calculate.html#pygmin.utils.disconnectivity_graph.DisconnectivityGraph.calculate">[docs]</a>    <span class="k">def</span> <span class="nf">calculate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        do the calculations necessary to draw the diconnectivity graph</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#find a reduced graph with only those connected to min0</span>
<span class="c">#        nodes = nx.node_connected_component(self.graph, self.min0)</span>
<span class="c">#        self.graph = self.graph.subgraph(nodes)</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reduce_graph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min0list</span><span class="p">)</span>

        <span class="c">#define the energy levels</span>
        <span class="n">elevels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_energy_levels</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
        
        <span class="c">#remove more nodes</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_high_energy_minima</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">elevels</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_nodes_with_few_edges</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        
        <span class="c">#make the tree graph defining the discontinuity of the minima</span>
        <span class="n">tree_graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_tree</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">elevels</span><span class="p">)</span>
        
        <span class="c">#layout the x positions of the minima and the nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_layout_x_axis</span><span class="p">(</span><span class="n">tree_graph</span><span class="p">)</span>

        <span class="c">#get the line segments which will be drawn to define the graph</span>
        <span class="n">eoffset</span> <span class="o">=</span> <span class="p">(</span><span class="n">elevels</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">elevels</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.2</span>  <span class="c">#this should be passable</span>
        <span class="n">line_segments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_line_segments</span><span class="p">(</span><span class="n">tree_graph</span><span class="p">,</span> <span class="n">eoffset</span><span class="o">=</span><span class="n">eoffset</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">tree_graph</span> <span class="o">=</span> <span class="n">tree_graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">line_segments</span> <span class="o">=</span> <span class="n">line_segments</span>
    </div>
<div class="viewcode-block" id="DisconnectivityGraph.plot"><a class="viewcode-back" href="../../../generated/pygmin.utils.disconnectivity_graph.DisconnectivityGraph.plot.html#pygmin.utils.disconnectivity_graph.DisconnectivityGraph.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">show_minima</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="c">#draw the minima as points</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">))</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="s">&#39;white&#39;</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">adjustable</span><span class="o">=</span><span class="s">&#39;box&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s">&#39;y&#39;</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s">&#39;out&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">tick_left</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s">&#39;left&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="s">&#39;black&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s">&#39;left&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_linewidth</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s">&#39;top&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="s">&#39;none&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s">&#39;bottom&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="s">&#39;none&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s">&#39;right&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="s">&#39;none&#39;</span><span class="p">)</span>
        <span class="n">leaves</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_graph</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()</span>
        <span class="n">energies</span> <span class="o">=</span> <span class="p">[</span><span class="n">leaf</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;minimum&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">energy</span> <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">leaves</span><span class="p">]</span>
        <span class="n">xpos</span> <span class="o">=</span> <span class="p">[</span><span class="n">leaf</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;x&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">leaves</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">show_minima</span><span class="p">:</span>      
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xpos</span><span class="p">,</span> <span class="n">energies</span><span class="p">,</span> <span class="s">&#39;o&#39;</span><span class="p">)</span>
        
        <span class="c">#draw the line segemnts</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_segments</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s">&#39;k&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
            
        <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">([])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">box</span><span class="p">(</span><span class="n">on</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        
    
        
<span class="c">#        import pylab as pl</span>
<span class="c">#        pl.ioff()</span>
<span class="c">##        nx.draw(self.graph, with_labels=False)</span>
<span class="c">##        pl.show()</span>
<span class="c">#        nx.draw(tree_graph, with_labels=False)</span>
<span class="c">#        pl.show()</span>
<span class="c">#        print &quot;done drawing&quot;</span>
        
        
        
    </div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">pygmin 0.1 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Victor Rühle, Jacob Stevenson.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>